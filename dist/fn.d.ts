import { IOptional } from "./optional";
import { IEither } from "./either";
export declare type Fn0<R> = () => R;
export declare type Fn<P1, R> = (p1: P1) => R;
export declare type Fn2<P1, P2, R> = (p1: P1, p2: P2) => R;
export declare type Fn3<P1, P2, P3, R> = (p1: P1, p2: P2, p3: P3) => R;
export declare type Fn4<P1, P2, P3, P4, R> = (p1: P1, p2: P2, p3: P3, p4: P4) => R;
export declare type Fn5<P1, P2, P3, P4, P5, R> = (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5) => R;
export declare type Fn6<P1, P2, P3, P4, P5, P6, R> = (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6) => R;
export declare type Fn7<P1, P2, P3, P4, P5, P6, P7, R> = (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7) => R;
export declare type Fn8<P1, P2, P3, P4, P5, P6, P7, P8, R> = (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8) => R;
export declare type AsyncFn0<R> = Fn0<Promise<R>>;
export declare type AsyncFn<P1, R> = Fn<P1, Promise<R>>;
export declare type AsyncFn2<P1, P2, R> = Fn2<P1, P2, Promise<R>>;
export declare type AsyncFn3<P1, P2, P3, R> = Fn3<P1, P2, P3, Promise<R>>;
export declare type AsyncFn4<P1, P2, P3, P4, R> = Fn4<P1, P2, P3, P4, Promise<R>>;
export declare type AsyncFn5<P1, P2, P3, P4, P5, R> = Fn5<P1, P2, P3, P4, P5, Promise<R>>;
export declare type AsyncFn6<P1, P2, P3, P4, P5, P6, R> = Fn6<P1, P2, P3, P4, P5, P6, Promise<R>>;
export declare type AsyncFn7<P1, P2, P3, P4, P5, P6, P7, R> = Fn7<P1, P2, P3, P4, P5, P6, P7, Promise<R>>;
export declare type AsyncFn8<P1, P2, P3, P4, P5, P6, P7, P8, R> = Fn8<P1, P2, P3, P4, P5, P6, P7, P8, Promise<R>>;
export declare type Consumer<T> = Fn<T, void>;
export declare type Supplier<T> = Fn0<T>;
export declare type Predicate<T> = Fn<T, boolean>;
export declare type Reducer<T> = Fn2<T, T, T>;
export declare type Comparator<T> = Fn2<T, T, -1 | 0 | 1>;
export declare type Callback = Fn0<void>;
export declare const FnUtils: {
    bindInvoker: <T, R>(val: T) => (fn: Fn<T, R>) => R;
    compose: <T1, T2, T3>(first: Fn<T1, T2>, second: Fn<T2, T3>) => Fn<T1, T3>;
    doAfter: <F extends (...args: any[]) => any>(fn: F, op: (retval: ReturnType<F>) => void) => (...args: Parameters<F>) => ReturnType<F>;
    doBefore: <F extends (...args: any[]) => any>(fn: F, op: (...args: Parameters<F>) => void) => (...args: Parameters<F>) => ReturnType<F>;
    ifElse: <R>(expr: boolean, onTrue: Fn0<R>, onFalse: Fn0<R>) => R;
    liftConsumer: <T>(fn: Fn<T, void>) => (param: T) => T;
    liftNullable: <T, R>(fn: Fn<T, R | null | undefined>) => Fn<T, IOptional<R>>;
    liftProperty: <T, F extends keyof T>(field: F) => (param: T) => T[F];
    makeBatchReducer: <T, R>(reducer: Fn2<R, R, R>, operations: Fn<T, R>[]) => Fn<T, R>;
    matchCompose: <T, R, CaseType extends string | number | symbol>(matcher: Fn<T, CaseType>, cases: Record<CaseType, Fn<T, R>>) => (param: T) => R;
    partial1: <T1, R>(p1: T1, fn: Fn<T1, R>) => () => R;
    partial2: <T1, T2, R>(p1: T1, fn: Fn2<T1, T2, R>) => (p2: T2) => R;
    partial3: <T1, T2, T3, R>(p1: T1, fn: Fn3<T1, T2, T3, R>) => (p2: T2, p3: T3) => R;
    partial4: <T1, T2, T3, T4, R>(p1: T1, fn: Fn4<T1, T2, T3, T4, R>) => (p2: T2, p3: T3, p4: T4) => R;
    liftTry: <T, R, E>(fn: Fn<T, R>) => Fn<T, IEither<R, E>>;
};
