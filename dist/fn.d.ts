export declare type Fn0<R> = () => R;
export declare type Fn<P1, R> = (p1: P1) => R;
export declare type Fn2<P1, P2, R> = (p1: P1, p2: P2) => R;
export declare type Fn3<P1, P2, P3, R> = (p1: P1, p2: P2, p3: P3) => R;
export declare type Fn4<P1, P2, P3, P4, R> = (p1: P1, p2: P2, p3: P3, p4: P4) => R;
export declare type AsyncFn0<R> = Fn0<Promise<R>>;
export declare type AsyncFn<P1, R> = Fn<P1, Promise<R>>;
export declare type AsyncFn2<P1, P2, R> = Fn2<P1, P2, Promise<R>>;
export declare type AsyncFn3<P1, P2, P3, R> = Fn3<P1, P2, P3, Promise<R>>;
export declare type AsyncFn4<P1, P2, P3, P4, R> = Fn4<P1, P2, P3, P4, Promise<R>>;
export declare type Consumer<T> = Fn<T, void>;
export declare type Supplier<T> = Fn0<T>;
export declare type Predicate<T> = Fn<T, boolean>;
export declare type Reducer<T> = Fn2<T, T, T>;
export declare type Comparator<T> = Fn2<T, T, -1 | 0 | 1>;
export declare type Callback = Fn0<void>;
export declare const FnUtils: {
    bindInvoker: <T, R>(val: T) => (fn: Fn<T, R>) => R;
    compose: <T1, T2, T3>(first: Fn<T1, T2>, second: Fn<T2, T3>) => Fn<T1, T3>;
    doAfter: <F extends (...args: any[]) => any>(fn: F, op: (retval: ReturnType<F>) => void) => (...args: Parameters<F>) => ReturnType<F>;
    doBefore: <F extends (...args: any[]) => any>(fn: F, op: (...args: Parameters<F>) => void) => (...args: Parameters<F>) => ReturnType<F>;
    ifElse: <R>(expr: boolean, onTrue: Fn0<R>, onFalse: Fn0<R>) => R;
    makeBatchReducer: <T, R>(reducer: Fn2<R, R, R>, operations: Fn<T, R>[]) => Fn<T, R>;
    partial1: <T1, R>(p1: T1, fn: Fn<T1, R>) => () => R;
    partial2: <T1, T2, R>(p1: T1, fn: Fn2<T1, T2, R>) => (p2: T2) => R;
    partial3: <T1, T2, T3, R>(p1: T1, fn: Fn3<T1, T2, T3, R>) => (p2: T2, p3: T3) => R;
    partial4: <T1, T2, T3, T4, R>(p1: T1, fn: Fn4<T1, T2, T3, T4, R>) => (p2: T2, p3: T3, p4: T4) => R;
    matchCompose: <T, R, CaseType extends string | number | symbol>(matcher: Fn<T, CaseType>, cases: Record<CaseType, Fn<T, R>>) => (param: T) => R;
};
